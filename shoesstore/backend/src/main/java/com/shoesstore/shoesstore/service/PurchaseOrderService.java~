package com.shoesstore.shoesstore.service;

import com.shoesstore.shoesstore.model.*;
import com.shoesstore.shoesstore.repository.*;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.web.multipart.MultipartFile;
import java.io.IOException;
import java.math.BigDecimal;
import java.math.RoundingMode;
import java.time.LocalDate;
import java.util.List;
import java.util.Map;
import java.util.UUID;
import java.util.stream.Collectors;


@Service
@Transactional
public class PurchaseOrderService {

    private final PurchaseOrderRepository        orderRepo;
    private final ProductRepository              productRepo;
    private final SupplierRepository             supplierRepo;
    private final UserRepository                 userRepository;
    private final FileStorageService             fileStorageService;

    public PurchaseOrderService(PurchaseOrderRepository orderRepo,
                                ProductRepository productRepo,
                                SupplierRepository supplierRepo,
                                UserRepository userRepository,
                                FileStorageService fileStorageService) {
        this.orderRepo           = orderRepo;
        this.productRepo         = productRepo;
        this.supplierRepo        = supplierRepo;
        this.userRepository      = userRepository;
        this.fileStorageService  = fileStorageService;
    }

    public List<PurchaseOrder> findAll() {
        return orderRepo.findAll();
    }

    public PurchaseOrder findById(Long id) {
        return orderRepo.findById(id).orElse(null);
    }

    public void completeOrder(Long id) {
        PurchaseOrder po = findById(id);
        if (po == null || po.isCompleted()) return;

        po.setCompleted(true);
        po.getItems().forEach(item -> {
            Product p = item.getProduct();
            p.setStock(p.getStock() + item.getQuantity());
            productRepo.save(p);
        });
        orderRepo.save(po);
    }

    @Transactional
    public PurchaseOrder createOrder(PurchaseOrder order,
                                     Long supplierId,
                                     Map<Long,Integer> qtys,
                                     BigDecimal discountPctPercent,
                                     BigDecimal shippingCost,
                                     MultipartFile attachment) throws Exception {
        Supplier supplier = supplierRepo.findById(supplierId)
                .orElseThrow(() -> new IllegalArgumentException("Proveedor no encontrado"));

        // 1) Calcular subtotal y crear líneas de detalle
        BigDecimal subtotal = BigDecimal.ZERO;
        for (Map.Entry<Long,Integer> e : qtys.entrySet()) {
            if (e.getValue() <= 0) continue;
            Product prod = productRepo.findById(e.getKey())
                    .orElseThrow(() -> new IllegalArgumentException("Producto no encontrado"));
            BigDecimal linePrice = prod.getPrice();
            BigDecimal lineTotal = linePrice.multiply(BigDecimal.valueOf(e.getValue()));
            subtotal = subtotal.add(lineTotal);

            PurchaseOrderLine line = new PurchaseOrderLine();
            line.setProduct(prod);
            line.setQuantity(e.getValue());
            line.setUnitPrice(linePrice);
            line.setLineTotal(lineTotal);
            line.setPurchaseOrder(order);
            order.getLines().add(line);
        }

        // 2) Descuento
        BigDecimal discountRate = discountPctPercent
                .divide(BigDecimal.valueOf(100), 4, RoundingMode.HALF_UP);
        BigDecimal discountAmount = subtotal.multiply(discountRate);

        // 3) IVA (21%)
        BigDecimal baseImponible = subtotal.subtract(discountAmount);
        BigDecimal iva = baseImponible.multiply(BigDecimal.valueOf(0.21))
                .setScale(2, RoundingMode.HALF_UP);

        // 4) Total final
        BigDecimal total = baseImponible.add(iva).add(shippingCost);

        // 5) Asignar todo a la entidad
        order.setSupplier(supplier);
        order.setOrderDate(LocalDate.now());
        order.setSubtotal(subtotal.setScale(2, RoundingMode.HALF_UP));
        order.setDiscountPct(discountPctPercent);
        order.setDiscountAmount(discountAmount.setScale(2, RoundingMode.HALF_UP));
        order.setIva(iva);
        order.setShippingCost(shippingCost.setScale(2, RoundingMode.HALF_UP));
        order.setTotal(total.setScale(2, RoundingMode.HALF_UP));

        // 6) (Opcional) Guardar adjunto en disco/Base64 en BD...
        if (attachment != null && !attachment.isEmpty()) {
            // Ejemplo: order.setAttachment(attachment.getBytes());
        }

        return orderRepo.save(order);
    }

    @Transactional
    public void updateOrder(
            Long orderId, // Nuevo parámetro para identificar la orden existente
            PurchaseOrder purchaseOrderData, // Datos actualizados de la orden
            Long supplierId,
            Map<Long, Integer> productsAndQuantities,
            BigDecimal discountPct,
            BigDecimal shippingCost,
            MultipartFile file
    ) throws IOException {
        // Validaciones básicas
        if (discountPct.compareTo(BigDecimal.ZERO) < 0) {
            throw new IllegalArgumentException("El descuento no puede ser negativo");
        }
        if (shippingCost.compareTo(BigDecimal.ZERO) < 0) {
            throw new IllegalArgumentException("El costo de envío no puede ser negativo");
        }

        // Buscar la orden existente
        PurchaseOrder existingOrder = orderRepo.findById(orderId)
                .orElseThrow(() -> new IllegalArgumentException("La orden no existe"));

        // Buscar proveedor
        Supplier supplier = supplierRepo.findById(supplierId)
                .orElseThrow(() -> new IllegalArgumentException("Proveedor no existe"));

        // Actualizar campos de la orden existente
        existingOrder.setSupplier(supplier);
        existingOrder.setDispatchDate(purchaseOrderData.getDispatchDate());
        existingOrder.setPriorityCondition(purchaseOrderData.getPriorityCondition());
        existingOrder.setDiscount(discountPct);
        existingOrder.setShippingCost(shippingCost);

        // Eliminar ítems existentes
        existingOrder.getItems().clear();

        // Crear nuevos ítems
        List<PurchaseOrderItem> items = productsAndQuantities.entrySet().stream()
                .filter(e -> e.getValue() > 0)
                .map(e -> {
                    Product p = productRepo.findById(e.getKey())
                            .orElseThrow(() -> new IllegalArgumentException("Producto no existe"));
                    PurchaseOrderItem item = new PurchaseOrderItem();
                    item.setOrder(existingOrder);
                    item.setProduct(p);
                    item.setQuantity(e.getValue());
                    item.setPurchasePrice(BigDecimal.valueOf(p.getPrice()));
                    return item;
                })
                .collect(Collectors.toList());

        if (items.isEmpty()) {
            throw new IllegalArgumentException("La orden debe contener al menos un producto");
        }
        existingOrder.setItems(items);

        // Cálculos de resumen
        BigDecimal subtotal = items.stream()
                .map(i -> i.getPurchasePrice().multiply(BigDecimal.valueOf(i.getQuantity())))
                .reduce(BigDecimal.ZERO, BigDecimal::add);

        BigDecimal discountAmt = subtotal.multiply(discountPct)
                .divide(BigDecimal.valueOf(100), 2, RoundingMode.HALF_UP);

        BigDecimal ivaAmt = subtotal.subtract(discountAmt)
                .multiply(BigDecimal.valueOf(0.21))
                .setScale(2, RoundingMode.HALF_UP);

        BigDecimal total = subtotal
                .subtract(discountAmt)
                .add(ivaAmt)
                .add(shippingCost)
                .setScale(2, RoundingMode.HALF_UP);

        existingOrder.setIva(ivaAmt);
        existingOrder.setTotal(total);

        // Procesar archivo adjunto
        if (file != null && !file.isEmpty()) {
            // Eliminar archivo anterior si existe
            if (existingOrder.getAttachment() != null) {
                fileStorageService.deleteFile(existingOrder.getAttachment().getStoragePath());
            }

            String relativePath = fileStorageService.storeFileForOrder(existingOrder.getId(), file);
            PurchaseOrderAttachment att = new PurchaseOrderAttachment(
                    file.getOriginalFilename(),
                    file.getContentType(),
                    relativePath,
                    file.getSize(),
                    existingOrder
            );
            existingOrder.setAttachment(att);
        }

        // Guardar la orden actualizada
        orderRepo.save(existingOrder);
    }


    @Transactional
    public void deleteOrder(Long id) throws Exception {
        // 1. Buscar la orden
        PurchaseOrder order = orderRepo.findById(id).orElseThrow(() -> new Exception("Orden no encontrada"));

        // 2. Eliminar archivo adjunto si existe
        if (order.getAttachment() != null) {
            fileStorageService.deleteFile(order.getAttachment().getStoragePath());
        }

        // 3. Eliminar la orden
        orderRepo.delete(order);
    }

}
